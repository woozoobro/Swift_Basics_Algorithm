- Constant time
O(1) -> same amount of time, regardless of the number of elements -> Random access array

- Logarithmic
O(logn) -> When doubling the number of elements doesn't double the time(binary trees) -> Search algorithms

- Linear
O(n) -> Adding element increases runtime linearly -> Looping through array / list

- Quasilinear
O(nlogn) -> every element has to be compared with every other element -> sorting algorithms

- Quadratic
O(n^2) -> 2, 4, 8, 16, 32 Increases quadratically -> Nested loops

- Exponential
O(2^n) -> Recursion -> Fibinacci series